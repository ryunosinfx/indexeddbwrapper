var indexeddbwrapper=function(e){var t={};function a(r){if(t[r])return t[r].exports;var s=t[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,a),s.l=!0,s.exports}return a.m=e,a.c=t,a.d=function(e,t,r){a.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},a.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.t=function(e,t){if(1&t&&(e=a(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(a.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)a.d(r,s,function(t){return e[t]}.bind(null,s));return r},a.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return a.d(t,"a",t),t},a.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},a.p="/dest/",a(a.s=0)}([function(e,t,a){"use strict";a.r(t);var r={dbName:"IDBWrapper",ua:navigator.userAgent.replace(/[\.0-9]+/g,"x"),domain:window.location,keypathName:"pk"};class s{static currentTables(e,t){return t||[e]}static isMutch(e,t){if(null==t)return!1;if(Array.isArray(t)){for(let a of t)if(s.isMutch(e,a))return!0;return!1}for(let a in t){let r=t[a];if("object"==typeof r){if(s.isMutch(e,r))return!0}else{if(e[a]!==r)return!1}}return!0}static makeKeyRange(e,t,a,r){return void 0===a&&void 0===r?IDBKeyRange.bound(e,t,!1,!1):IDBKeyRange.bound(e,t,a,r)}static makeKeyRangeUpper(e,t){return!0!==t?IDBKeyRange.upperBound(e):IDBKeyRange.upperBound(e,t)}static makeKeyRangeLower(e,t){return!0!==isNotEqualStart?KeyRange.lowerBound(e):IDBKeyRange.lowerBound(e,t)}static makeKeyRangeOnly(e){return!0!==isNotEqualStart?IDBKeyRange.only(e):IDBKeyRange.lowerBound(end,isNotEqualEnd)}static buildKeyPath(e,t,a,r,s){let n=[];return void 0!==e&&n.push((e+"").split("&").join("&amp;").split(".").join("&#046;")),void 0!==t&&n.push((t+"").split("&").join("&amp;").split(".").join("&#046;")),void 0!==a&&n.push((a+"").split("&").join("&amp;").split(".").join("&#046;")),void 0!==r&&n.push((r+"").split("&").join("&amp;").split(".").join("&#046;")),void 0!==s&&n.push((s+"").split("&").join("&amp;").split(".").join("&#046;")),n.join("")}}const n="readonly",i="readwrite";class c{constructor(e){this.IDBKeyRange=window.IDBKeyRange,this.indexedDB=window.indexedDB,this.dbName=e,this.keyPathMap={},this.db=null,this.lastVersion=null,this.isUpdateOpen=!1,this.timer=null,this.isDBClosed=!0,this.tableCache={}}getOpenDB(e){return new Promise((t,a)=>{if(this.lastVersion=e,this.lastVersion&&this.db)this.db.close(),this.isUpdateOpen=!0;else{if(this.db&&!1===this.isDBClosed)return void t(this.db);this.lastVersion?this.isUpdateOpen=!0:this.isUpdateOpen=!1}let r=this.indexedDB.open(this.dbName,e);r.onsuccess=e=>{this.db=e.target.result,this.isDBClosed=!1,t(this.db)},r.onupgradeneeded=e=>{this.db=e.target.result,this.isDBClosed=!1,t(this.db)},r.onabort=e=>{t(e)},r.onerror=e=>{a(e)}})}closeDB(){this.isUpdateOpen?(this.db.close(),this.isDBClosed=!0):(this.timer&&clearTimeout(this.timer),this.timer=setTimeout(()=>{this.db.close(),this.isDBClosed=!0},1e3))}cacheClear(){const e=[];for(let t in this.tableCache)e.push(t);for(let t of e){const e=this.tableCache[t];for(let t in e)delete e[t]}}setCache(e,t,a){if(!a||!a.data)return;const r=a.data;for(let e in r){const t=r[e];if(t&&t.byteLength)return}this.tableCache[e]||(this.tableCache[e]={}),this.tableCache[e][t]=a}getCache(e,t){const a=this.tableCache[e];return a?a[t]:null}getObjectStore(e,t,a,r){r===n&&this.cacheClear();let s=e.transaction(a,r);return s.oncomplete=e=>{this.closeDB()},s.onerror=e=>{this.closeDB()},s.objectStore(t)}throwNewError(e){return t=>{throw console.error(t),t.stack?console.log(t.stack):console.log(t.message,t),console.error(e||"/"+t),new Error(t)}}getKeyPathByMap(e){return this.keyPathMap[e]}async getKeyPath(e){let t=this.keyPathMap[e];if(null!=t)return t;const a=await this.getOpenDB().catch(this.throwNewError("getKeyPath->getOpenDB"));let r=this.getObjectStore(a,e,[e],n);this.closeDB();let s=r.keyPath;return this.keyPathMap[e]=s,s}async getCurrentVersion(){const e=(await this.getOpenDB().catch(this.throwNewError("getCurrentVersion->getOpenDB"))).version;return this.closeDB(),e}async selectAll(e){let{tableName:t,range:a,condetions:r}=e;return await this._selectAll(t,a,r)}async _selectAll(e,t,a,r,s,i){const c=await this.getOpenDB().catch(this.throwNewError("_selectAll->getOpenDB tableName:"+e));let o=this.getObjectStore(c,e,[e],n);return await this._selectAllExecute(o,t,!1,r,s,i)}_selectAllExecute(e,t,a,r,s,n){return new Promise((i,c)=>{const o="function"==typeof r,l="number"==typeof r&&"number"==typeof s&&r>0&&s>0,h=r+s,u=[];let d=0,m=void 0===t?e.openCursor():e.openCursor(t);m.onsuccess=e=>{let t=e.target.result;if(t){const e=t.value;if(o&&!n(e))return void t.continue();if(l){if(r>d)return d++,void t.continue();if(h<d)return void i(u)}if(u.push(e),a)return void i(u[0]);d++,t.continue()}else i(u)},m.onerror=e=>{c(e)}})}async selectByKey(e){let{tableName:t,key:a}=e;return await this._selectByKey(t,a)}async _selectByKey(e,t){const a=await this.getOpenDB().catch(this.throwNewError("_selectByKey->getOpenDB tableName:"+e));return await this._selectByKeyOnTran(a,e,t).catch(this.throwNewError("_selectByKey->_selectByKeyOnTran tableName:"+e+"/mode:"+n))}_selectByKeyOnTran(e,t,a,r,s=n){return new Promise((r,n)=>{const i=t+"_"+s,c=this.getCache(i,a);if(c)r(c);else{let c=this.getObjectStore(e,t,[t],s).get(a);c.onsuccess=e=>{const t=c.result;r(t),this.setCache(i,a,t)},c.onerror=e=>{n(e)}}})}async selectByKeys(e){let{tableName:t,keys:a}=e;return await this._selectByKeys(t,a)}async _selectByKeys(e,t){const a=await this.getOpenDB().catch(this.throwNewError("_selectByKeys->getOpenDB tableName:"+e));return await this._selectByKeysOnTran(a,e,t).catch(this.throwNewError("_selectByKeys->_selectByKeyOnTran tableName:"+e))}async _selectByKeysOnTran(e,t,a,r){let s=this.getObjectStore(e,t,[t],n);return await this._selectByKeysOnTranExec(s,a,t)}async _selectByKeysOnTranExec(e,t,a){const r={};for(let s of t){const t=this.getCache(a,s),n=t||await this._getByKeyFromeObjectStore(e,s);t||this.setCache(a,s,n),r[s]=n}return r}_getByKeyFromeObjectStore(e,t){return new Promise((a,r)=>{t||a(null);let s=e.get(t);s.onsuccess=e=>{a(s.result)},s.onerror=e=>{r(e)}})}async selectFirstOne(e){let{tableName:t,range:a,direction:r}=e;return await this._selectFirstOne(t,a,r)}async _selectFirstOne(e,t,a){const r=await this.getOpenDB().catch(this.throwNewError("_selectFirstOne->getOpenDB tableName:"+e));let s=this.getObjectStore(r,e,[e],n);return await this._selectAllExecute(s,t,!0)}async insertUpdate(e){let{tableName:t,data:a,callback:r}=e;const s=this.getKeyPathByMap();return await this._insertUpdate(t,s,a,r).catch(this.throwNewError("insertUpdate->_insertUpdate tableName:"+t))}async bulkInsertUpdate(e,t,a,r){for(let s of a)await this._insertUpdate(e,t,record,r)}async _bulkInsertUpdate(e,t,a,r){const n=[],c=[];for(let e of a){const a=e[t];n.push({key:a,data:record}),c.push(a)}const o=await this.getOpenDB().catch(this.throwNewError("_insertUpdate->getOpenDB tableName:"+e)),l=s.currentTables(e),h=this.getObjectStore(o,e,l,i),u=await this._selectByKeysOnTranExec(h,c,e);await this._bulkUpdateExecute(h,e,n,u),await this._bulkInsertExecute(h,e,n,u),"function"==typeof r&&r()}_bulkInsertExecute(e,t,a,r){const s=[];for(const{key:t,data:n}of a){if(r[t])continue;const a=this._bulkInsertExecuteOne(e,t,n);s.push(a)}return Promise.all(s)}_bulkInsertExecuteOne(e,t,a){return new Promise((r,s)=>{let n=e.add(a);n.onsuccess=e=>{r({data:a,key:t})},n.onerror=e=>{console.error(e),s(e)}})}_bulkUpdateExecute(e,t,a,r){const s=[];for(const{key:t,data:n}of a){if(!r[t])continue;const a=this._bulkUpdateExecuteOne(e,t,n);s.push(a)}return Promise.all(s)}_bulkUpdateExecuteOne(e,t,a){return new Promise((r,s)=>{let n=e.put(a);n.onsuccess=e=>{r({data:a,key:t})},n.onerror=e=>{console.error(e),s(e)}})}async _insertUpdate(e,t,a,r){const n=a[t],c=await this.getOpenDB().catch(this.throwNewError("_insertUpdate->getOpenDB tableName:"+e)),o=s.currentTables(e),l=await this._selectByKeyOnTran(c,e,n,o,i).catch(this.throwNewError("_insertUpdate->_selectByKeyOnTran tableName:"+e+"/MODE_RW"));return r&&r(l,a),void 0===l?await this._insertExecute(c,e,n,a,o).catch(this.throwNewError("_insertUpdate->_insertExecute tableName:"+e)):await this._updateExecute(c,e,n,a,o).catch(this.throwNewError("_insertUpdate->_updateExecute tableName:"+e))}_insertExecute(e,t,a,r,s){let n=this.getObjectStore(e,t,s,i);return new Promise((e,t)=>{let s=n.add(r);s.onsuccess=t=>{e({data:r,key:a})},s.onerror=e=>{console.error(e),t(e)}})}_updateExecute(e,t,a,r,s){return new Promise((n,c)=>{let o=this.getObjectStore(e,t,s,i).put(r);o.onsuccess=e=>{n({data:r,key:a})},o.onerror=e=>{console.error(e),n(e)}})}async deleteWithRange(e){let{tableName:t,range:a,condetions:r}=e;return await this._deleteWithRange(t,a,r)}async _deleteWithRange(e,t,a){const r=await this.getOpenDB().catch(this.throwNewError("_deleteWithRange->getOpenDB tableName:"+e)),n=s.currentTables(e);return await this._deleteWithRangeExecute(r,e,t,a,n)}_deleteWithRangeExecute(e,t,a,r,n){return new Promise((c,o)=>{let l=this.getObjectStore(e,t,n,i),h=l.openCursor(a);h.onsuccess=e=>{let t=e.target.result,a=[];if(t){let e=t.value;if(s.isMutch(e,r)){let r=l.delete(t.key);r.onsuccess=t=>{a.push(e)},r.onerror=e=>{}}t.continue()}else c(a)},h.onerror=e=>{o(e)}})}async delete(e){let{tableName:t,key:a}=e;return await this._delete(t,a)}async _delete(e,t){const a=await this.getOpenDB().catch(this.throwNewError("_delete->getOpenDB tableName:"+e)),r=s.currentTables(e);return await this._deleteOnTran(a,e,t,r)}_deleteOnTran(e,t,a,r){return new Promise((s,n)=>{let c=this.getObjectStore(e,t,r,i).delete(a+"");c.onsuccess=e=>{s({tableName:t,key:a})},c.onerror=e=>{console.error(e),n(e)}})}async truncate(e){let{tableName:t}=e;return await this._truncate(t)}async _truncate(e){const t=await this.getOpenDB().catch(this.throwNewError("_truncate->getOpenDB tableName:"+e)),a=s.currentTables(e);return await this._truncateExecute(t,e,a)}_truncateExecute(e,t,a){return new Promise((r,s)=>{let n=this.getObjectStore(e,t,a,i).clear();n.onsuccess=e=>{r()},n.onerror=e=>{s(e)}})}async getObjectStoreNames(){const e=(await this.getOpenDB().catch(this.throwNewError("getObjectStoreNames->getOpenDB"))).objectStoreNames;return this.closeDB(),e}async isExistsObjectStore(e){const t=await this.getOpenDB().catch(this.throwNewError("isExistsObjectStore->getOpenDB tableName:"+e));let a=!1;for(let r of t.objectStoreNames)if(r===e){a=!0;break}return this.closeDB(),a}async createIndex(e,t,a){const r=await this.getOpenDB().catch(this.throwNewError("getObjectStoreNames->getOpenDB")),s=r.objectStoreNames;return this._createIndex(r,e,t,a),this.closeDB(),s}_createIndex(e,t,a,r){const n=s.currentTables(t),c=t+"-"+a;return this.getObjectStore(e,t,n,i).createIndex(c,a,{multiEntry:!!r})}async getIndexNames(e){const t=s.currentTables(e),a=await this.getOpenDB().catch(this.throwNewError("getObjectStoreNames->getOpenDB")),r=this.getObjectStore(a,e,t,i).indexNames;return this.closeDB(),r}async deleteIndex(e){const t=(await this.getOpenDB().catch(this.throwNewError("getObjectStoreNames->getOpenDB"))).objectStoreNames;return this.closeDB(),t}_deleteIndex(e,t){const a=s.currentTables(t),r=this.getObjectStore(e,t,a,i),n=t+"-"+keyPath;return r.indexNames.includes(n)?r.deleteIndex(n):null}async createStore(e){let{tableName:t,keyPathName:a,isAutoIncrement:r}=e;return await this._createStore(t,a,r)}async _createStore(e,t,a){if(!1===await this.isExistsObjectStore()){const a=await this.getCurrentVersion()+1,r=await this.getOpenDB(a).catch(this.throwNewError("_createStore->getOpenDB tableName:"+e));let s=!1;for(let t of r.objectStoreNames)if(t===e){s=!0;break}!1===s&&r.createObjectStore(e,{keyPath:t}),this.closeDB()}}async dropStore(e){let{tableName:t}=e;return await this._dropStore(t)}async _dropStore(e){const t=await this.getCurrentVersion()+1;(await this.getOpenDB(t).catch(this.throwNewError("_dropStore->getOpenDB tableName:"+e))).deleteObjectStore(e),this.closeDB()}}const o="readonly",l="readwrite",h="cmdSelectAll",u="cmdSelectByKey",d="cmdSelectByKeys",m="cmdSelectFirstOne",y="cmdBulkInsertUpdate",b="cmdInsertUpdate",p="cmdDeleteWithRange",w="cmdDelete",g="cmdTruncate",N="cmdCreateStore",O="cmdDeleteStore",B="cmdCreateIndex",f="cmdDeleteIndex",k="cmdGetObjectStoreNames";class _{constructor(e){this.core=new c(e),this.queue=[],this.lastTaskMode=null,this.lastLockTime=(new Date).getTime(),this.counter=0}async deQueue(){this.counter<1&&(this.counter++,this.counter>1?(this.counter--,setTimeout(async()=>{await this.deQueue()},0)):(await this.deQueueExec(),this.counter--,this.counter<1&&this.queue.length>0&&this.deQueue()))}deQueueExec(){return new Promise((e,t)=>{for(;this.queue.length>0;){const a=[],r=[];for(;this.queue.length>0;){const s=this.queue.shift();if(s){if(this.lastTaskMode!==s.mode||s.mode===l)return void(a.length>0?Promise.all(a).then(t=>{for(let e in t){const a=r[e],s=t[e];a.resolve(s)}a.splice(0,a.length),this.executUpdateTask(s,e)},e=>{alert(e),t(e)}):this.executUpdateTask(s,e));{const e=this.execCmd(s.cmd,s.data);a.push(e),r.push(s)}this.lastTaskMode=s.mode}}a.length>0&&Promise.all(a).then(t=>{for(let e in t){const a=r[e],s=t[e];a.resolve(s)}a.splice(0,a.length),e()},e=>{alert(e),t(e)})}})}executSelectPromiseAndTask(e,t,a){a&&this.executUpdateTask(a,t)}executUpdateTask(e,t){this.execCmd(e.cmd,e.data).then(a=>{e.resolve(a),t(a)})}enQueueReadTask(e,t){return this.enQueueTask(e,t,o)}enQueueWriteTask(e,t){return this.enQueueTask(e,t,l)}enQueueTask(e,t,a){return new Promise((r,s)=>{const n={cmd:e,data:t,resolve:r,reject:s,mode:a};this.queue.push(n),this.deQueue()})}async execCmd(e,t){return h===e?await this.core._selectAll(t.tableName,t.range,t.direction,t.offset,t.limmitCount):u===e?await this.core._selectByKey(t.tableName,t.key):d===e?await this.core._selectByKeys(t.tableName,t.keys):m===e?await this.core._selectFirstOne(t.tableName,t.range,t.direction):y===e?await this.core._bulkInsertUpdate(t.tableName,t.keyPathName,t.data,t.callback):b===e?await this.core._insertUpdate(t.tableName,t.keyPathName,t.data,t.callback):p===e?await this.core._deleteWithRange(t.tableName,t.range,t.condetions):w===e?await this.core._delete(t.tableName,t.keyPathValue):g===e?await this.core._truncate(t.tableName):N===e?await this.core._createStore(t.tableName,t.keyPathName,t.isAutoIncrement):O===e?await this.core._deleteStore(t.tableName):B===e?await this.core._createIndex(t.tableName,t.keyPathName,t.isMultiColumns):f===e?await this.core._deleteIndex(t.tableName,t.indexName):k===e?await this.core.getObjectStoreNames():void 0}async selectAllForwardMatch(e,t,a,r,s){t.slice(0,-1),String.fromCharCode(t.slice(-1).charCodeAt()+1);const n=IDBKeyRange.bound(str,nextStr,!1,!0);return await this.enQueueReadTask(h,{tableName:e,range:n,direction:a,offset:r,limmitCount:s})}async selectAll(e,t,a,r,s){return await this.enQueueReadTask(h,{tableName:e,range:t,direction:a,offset:r,limmitCount:s})}async selectByKey(e,t){return await this.enQueueReadTask(u,{tableName:e,key:t})}async selectByKeys(e,t){return await this.enQueueReadTask(d,{tableName:e,keys:t})}async selectFirstOne(e,t,a){return await this.enQueueReadTask(m,{tableName:e,range:t,direction:a})}async bulkInsertUpdate(e,t,a,r){return await this.enQueueWriteTask(y,{tableName:e,keyPathName:t,data:a,callback:r})}async insertUpdate(e,t,a,r){return await this.enQueueWriteTask(b,{tableName:e,keyPathName:t,data:a,callback:r})}async deleteWithRange(e,t,a){return await this.enQueueWriteTask(p,{tableName:e,range:t,direction:direction})}async delete(e,t){return await this.enQueueWriteTask(w,{tableName:e,keyPathValue:t})}async truncate(e){return await this.enQueueWriteTask(g,{tableName:e})}async createStore(e,t,a){return await this.enQueueWriteTask(N,{tableName:e,keyPathName:t,isAutoIncrement:a})}async deleteStore(e){return await this.enQueueWriteTask(O,{tableName:e})}async creatIndex(e,t,a){return await this.enQueueWriteTask(B,{tableName:e,keyPathName:t,isMultiColumns:a})}async deleteIndex(e,t){return await this.enQueueWriteTask(f,{tableName:e,indexName:t})}async getObjectStoreNames(){return await this.enQueueReadTask(k,{})}}let D=r.dbName;const S=new Map;class x{constructor(e,t=r.keypathName,a=!1,s=D){S.has(s)?this.idbh=S.get(s):(this.idbh=new _(s),S.set(s,this.idbh)),this.keyPathName=t,this.objectStoreName=e,this.isAutoincrements=a}static setDbName(e){D=e}static async getInstance(e,t,a,r){const s=new x(e,t,a,r);return await s.init(),s}init(){return new Promise((e,t)=>{this.idbh.createStore(this.objectStoreName,this.keyPathName,this.isAutoincrements).then(()=>{e(!0)},e=>{throw t(e),e})})}async putByMap(e,t){const a={data:data};a[this.keyPathName]=key,await this.putRecord(a,void 0,t)}async put(e,t,a){const r={data:t};r[this.keyPathName]=e,await this.putRecord(r,void 0,a)}async putRecord(e,t,a){const r=e;return void 0===e[this.keyPathName]&&(r={data:e},r[this.keyPathName]=t),await this.idbh.insertUpdate(this.objectStoreName,this.keyPathName,r,a)}async getAsMap(e){if(void 0!==e){return await this.idbh.selectByKeys(this.objectStoreName,e)}return null}async getRecord(e){if(void 0!==e){return await this.idbh.selectByKey(this.objectStoreName,e)}return null}async get(e){const t=await this.getRecord(e);return null==t?null:t.data}async getAll(){return await this.idbh.selectAll(this.objectStoreName)}async delete(e){return void 0!==e?await this.idbh.delete(this.objectStoreName,e):null}async getOsNames(){return await this.idbh.getObjectStoreNames()}}const E=new Map;r.dbName;class j{constructor(e){this.dbName=e}async getObAccessor(e,t){if(E.has(e))return E.get(e);const a=new x(e,t,this.dbName);return E.set(e,a),await a.init(),a}}class T{constructor(e){this.frame=document.createElement("div");const t=document.createElement("div"),a=document.createElement("h1"),r=document.createElement("hr");a.textContent=e,t.appendChild(a),this.frame.appendChild(t),this.frame.appendChild(r),this.currentFrame=document.createElement("div"),this.frame.appendChild(this.currentFrame),this.time=Date.now()}createNewFrame(){const e=document.createElement("hr");this.frame.appendChild(e),this.currentFrame=document.createElement("div"),this.frame.appendChild(this.currentFrame)}setTitle(e){const t=document.createElement("h2"),a=document.createElement("hr");t.textContent=e,this.currentFrame.appendChild(t),this.currentFrame.appendChild(a)}log(e,t,a){const r=document.createElement("div");r.textContent=t+" "+e+" "+a,this.currentFrame.appendChild(r)}getDuration(){const e=Date.now(),t=e-this.time;return this.time,e+"/"+("00000000000"+t).substring(-10)}info(e){this.log("[INFO]",this.getDuration(),e)}warn(e){this.log("[WARN]",this.getDuration(),e)}error(e){this.log("[ERROR]",this.getDuration(),e)}}a.d(t,"indexedbwrapper",(function(){return P})),a.d(t,"db",(function(){return C})),a.d(t,"test",(function(){return K}));const P=j,C=j,K=class{constructor(){this.db=new j("indexeddbWrapper-test"),this.logger=new T("idbw test!")}execAll(){alert("test!")}test1(){this.db.getObAccessor("test","pk")}async test2(){this.db.getObAccessor("test","pk")}}}]);
//# sourceMappingURL=bundle.js.map