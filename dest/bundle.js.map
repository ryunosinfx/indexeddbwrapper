{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./index.js","webpack:///./src/constant.js","webpack:///./src/idbUtil.js","webpack:///./src/indexeddbAccessor.js","webpack:///./src/indexeddbCore.js","webpack:///./src/indexeddbHelper.js","webpack:///./src/indexeddbWrapper.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAA6C;AACtC,wBAAwB,0DAAI,C;;;;;;;;;;;;ACDnC;AAAA;AACA;AACe;AACf;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACPA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,C;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAiC;AACkB;AACnD;AACA,aAAa,iDAAQ;AACrB;AACA;AACO;AACP,4CAA4C,iDAAQ;AACpD;AACA,mBAAmB,gEAAe;AAClC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChGA;AAAA;AAAA;AAAmC;AACnC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,+BAA+B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO,iBAAiB;AACxB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO,kBAAkB;AACzB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO,8BAA8B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,4BAA4B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,iBAAiB,gDAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO,+BAA+B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,gDAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO,iBAAiB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO,YAAY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,0CAA0C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,YAAY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5jBA;AAAA;AAAA;AAAA;AAAmC;AACY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,4DAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mDAAmD;AACtG;AACA;AACA;AACA,mDAAmD,mDAAmD;AACtG;AACA,iCAAiC;AACjC;AACA,qDAAqD,iBAAiB;AACtE;AACA,iCAAiC;AACjC;AACA,sDAAsD,kBAAkB;AACxE;AACA;AACA;AACA,wDAAwD,8BAA8B;AACtF;;AAEA;AACA;AACA,uDAAuD,yCAAyC;AAChG;AACA;AACA;AACA,0DAA0D,8BAA8B;AACxF;AACA;AACA;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D;AACA;AACA;AACA,sDAAsD,0CAA0C;AAChG;AACA;AACA,8DAA8D;AAC9D;AACA,C;;;;;;;;;;;;AC7NA;AAAA;AAAA;AAAA;AAAuD;AACtB;AACjC;AACA,oBAAoB,iDAAQ;AACrB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAiB;AACxC;AACA;AACA;AACA;AACA,E","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dest/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","import { idbw } from './src/indexeddbWrapper'\nexport const indexedbwrapper = idbw;","const ua = navigator.userAgent.replace(/[\\.0-9]+/g, \"x\");\nconst domain = window.location;\nexport default {\n\tdbName: \"IDBWrapper\",\n\tua: ua,\n\tdomain: domain,\n\tkeypathName: \"pk\"\n}","export class IdbUtil {\n\tstatic currentTables(table, tabels) {\n\t\treturn tabels ? tabels : [table];\n\t}\n\t// static async getTransaction(db,tables,mode,reject,reject){\n\t//   let transaction = db.transaction(tables, mode);\n\t//   transaction.oncomplete = (event) => {\n\t//     db.close();\n\t//     resolve();\n\t//   };\n\t//   transaction.onerror = (event) => {\n\t//     db.close();\n\t//     reject();\n\t//   };\n\t// }\n\n\t//private\n\tstatic isMutch(value, condetions) {\n\t\tif (condetions === undefined || condetions === null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (Array.isArray(condetions)) {\n\t\t\tfor (let condition of condetions) {\n\t\t\t\tif (IdbUtil.isMutch(value, condition)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfor (let key in condetions) {\n\t\t\t\tlet condition = condetions[key];\n\t\t\t\tif (typeof condition === 'object') {\n\t\t\t\t\tif (IdbUtil.isMutch(value, condition)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet target = value[key];\n\t\t\t\t\tif (target !== condition) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t};\n\tstatic makeKeyRange(start, end, isNotEqualStart, isNotEqualEnd) {\n\t\treturn (isNotEqualStart === undefined && isNotEqualEnd === undefined) ?\n\t\t\tIDBKeyRange.bound(start, end, false, false) :\n\t\t\tIDBKeyRange.bound(start, end, isNotEqualStart, isNotEqualEnd);\n\t}\n\tstatic makeKeyRangeUpper(start, isNotEqualStart) {\n\t\treturn (isNotEqualStart !== true) ?\n\t\t\tIDBKeyRange.upperBound(start) :\n\t\t\tIDBKeyRange.upperBound(start, isNotEqualStart);\n\t}\n\tstatic makeKeyRangeLower(end, isNotEqualEnd) {\n\t\treturn (isNotEqualStart !== true) ?\n\t\t\tKeyRange.lowerBound(end) :\n\t\t\tIDBKeyRange.lowerBound(end, isNotEqualEnd);\n\t}\n\tstatic makeKeyRangeOnly(only) {\n\t\treturn (isNotEqualStart !== true) ?\n\t\t\tIDBKeyRange.only(only) :\n\t\t\tIDBKeyRange.lowerBound(end, isNotEqualEnd);\n\t}\n\t//IDを生成\n\tstatic buildKeyPath(key1, key2, key3, key4, key5) {\n\t\tlet array = [];\n\t\tif (key1 !== undefined) {\n\t\t\tarray.push((key1 + \"\")\n\t\t\t\t.split(\"&\")\n\t\t\t\t.join(\"&amp;\")\n\t\t\t\t.split(\".\")\n\t\t\t\t.join(\"&#046;\"));\n\t\t}\n\t\tif (key2 !== undefined) {\n\t\t\tarray.push((key2 + \"\")\n\t\t\t\t.split(\"&\")\n\t\t\t\t.join(\"&amp;\")\n\t\t\t\t.split(\".\")\n\t\t\t\t.join(\"&#046;\"));\n\t\t}\n\t\tif (key3 !== undefined) {\n\t\t\tarray.push((key3 + \"\")\n\t\t\t\t.split(\"&\")\n\t\t\t\t.join(\"&amp;\")\n\t\t\t\t.split(\".\")\n\t\t\t\t.join(\"&#046;\"));\n\t\t}\n\t\tif (key4 !== undefined) {\n\t\t\tarray.push((key4 + \"\")\n\t\t\t\t.split(\"&\")\n\t\t\t\t.join(\"&amp;\")\n\t\t\t\t.split(\".\")\n\t\t\t\t.join(\"&#046;\"));\n\t\t}\n\t\tif (key5 !== undefined) {\n\t\t\tarray.push((key5 + \"\")\n\t\t\t\t.split(\"&\")\n\t\t\t\t.join(\"&amp;\")\n\t\t\t\t.split(\".\")\n\t\t\t\t.join(\"&#046;\"));\n\t\t}\n\t\treturn array.join(\"\");\n\t};\n}","import constant from './constant'\nimport { IndexeddbHelper } from './indexeddbHelper'\nconst initQueue = [];\nlet dbName = constant.dbName;\n// stock par db\nconst idbHelperMap = new Map();\nexport class IndexeddbAccessor {\n\tconstructor(objectStoreName, keypathName = constant.keypathName, currentDbName = dbName) {\n\t\tif (!idbHelperMap.has(currentDbName)) {\n\t\t\tthis.idbh = new IndexeddbHelper(currentDbName);\n\t\t\tidbHelperMap.set(currentDbName, this.idbh);\n\t\t} else {\n\t\t\tthis.idbh = idbHelperMap.get(currentDbName);\n\t\t}\n\t\tthis.keyPathName = keypathName;\n\t\tthis.objectStoreName = objectStoreName;\n\t}\n\tstatic setDbName(dbNameNew) {\n\t\tdbName = dbNameNew;\n\t}\n\tinit() {\n\t\treturn new Promise((reslve, reject) => {\n\t\t\tthis.idbh.createStore(this.objectStoreName, this.keyPathName)\n\t\t\t\t.then(() => {\n\t\t\t\t\treslve(true)\n\t\t\t\t}, (e) => {\n\t\t\t\t\treject(e);\n\t\t\t\t\tthrow e;\n\t\t\t\t});\n\t\t});\n\t}\n\tasync putByMap(dataMap, callback) {\n\t\tconst record = {\n\t\t\tdata: data\n\t\t};\n\t\trecord[this.keyPathName] = key;\n\t\t//console.log(\"saveDataDefault 001:\" + key + \"/\" + data);\n\t\tawait this.putRecord(record, undefined, callback);\n\t\t//console.log(\"saveDataDefault 002:\" + key + \"/\" + data);\n\t}\n\tasync put(key, data, callback) {\n\t\tconst record = {\n\t\t\tdata: data\n\t\t};\n\t\trecord[this.keyPathName] = key;\n\t\t//console.log(\"saveDataDefault 001:\" + key + \"/\" + data);\n\t\tawait this.putRecord(record, undefined, callback);\n\t\t//console.log(\"saveDataDefault 002:\" + key + \"/\" + data);\n\t}\n\tasync putRecord(record, key, callback) {\n\t\t//console.log(\"saveData 001:\" + key + \"/\" + JSON.stringify(dataObj)+\"/dataObj.data:\"+dataObj.data);\n\t\tconst storeData = record;\n\t\t//console.log(\"saveData 002:\" + key + \"/\" + dataObj[this.keyPathName]);\n\t\tif (record[this.keyPathName] === undefined) {\n\t\t\tstoreData = {\n\t\t\t\tdata: record\n\t\t\t};\n\t\t\tstoreData[this.keyPathName] = key;\n\t\t} else if (key !== undefined) {}\n\t\t//console.log(\"saveData 003:\" + key + \"/\" + dataObj +\"/this.objectStoreName:\"+this.objectStoreName);\n\t\tconst value = await this.idbh.insertUpdate(this.objectStoreName, this.keyPathName, storeData, callback);\n\t\t//console.log(\"saveData 004:\" + key + \"/\" + dataObj+\"/\"+JSON.stringify(value)+\"/\"+value.data.data);\n\t\treturn value;\n\t}\n\tasync getAsMap(keys) {\n\t\tif (keys !== undefined) {\n\t\t\tconst recordAsLoadedData = await this.idbh.selectByKeys(this.objectStoreName, keys);\n\t\t\treturn recordAsLoadedData;\n\t\t}\n\t\treturn null;\n\t}\n\tasync getRecord(key) {\n\t\tif (key !== undefined) {\n\t\t\tconst recordAsLoadedData = await this.idbh.selectByKey(this.objectStoreName, key);\n\t\t\treturn recordAsLoadedData;\n\t\t}\n\t\treturn null;\n\t}\n\tasync get(key) {\n\t\tconst recordAsDefaultLoad = await this.getRecord(key);\n\t\treturn recordAsDefaultLoad === undefined || recordAsDefaultLoad === null ?\n\t\t\tnull :\n\t\t\trecordAsDefaultLoad.data;\n\t}\n\tasync getAll() {\n\t\treturn await this.idbh.selectAll(this.objectStoreName);\n\t}\n\tasync delete(key) {\n\t\tif (key !== undefined) {\n\t\t\treturn await this.idbh.delete(this.objectStoreName, key);\n\t\t}\n\t\treturn null;\n\t}\n\tasync getOsNames() {\n\t\treturn await this.idbh.getObjectStoreNames();\n\t}\n}","import { IdbUtil } from './idbUtil'\nconst MODE_R = \"readonly\";\nconst MODE_RW = \"readwrite\";\nexport class IndexeddbCore {\n\tconstructor(dbName) {\n\t\tthis.IDBKeyRange = window.IDBKeyRange;\n\t\tthis.indexedDB = window.indexedDB;\n\t\tthis.dbName = dbName;\n\t\tthis.keyPathMap = {};\n\t\tthis.db = null;\n\t\tthis.lastVersion = null;\n\t\tthis.isUpdateOpen = false;\n\t\tthis.timer = null;\n\t\tthis.isDBClosed = true;\n\t\tthis.tableCache = {};\n\t}\n\n\tgetOpenDB(newVersion) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastVersion = newVersion;\n\t\t\tif ((this.lastVersion) && this.db) {\n\t\t\t\tthis.db.close();\n\t\t\t\tthis.isUpdateOpen = true;\n\t\t\t\t// this.cacheClear();\n\t\t\t} else if (this.db && this.isDBClosed === false) {\n\t\t\t\tresolve(this.db);\n\t\t\t\treturn;\n\t\t\t} else if (this.lastVersion) {\n\t\t\t\tthis.isUpdateOpen = true;\n\t\t\t} else {\n\t\t\t\tthis.isUpdateOpen = false;\n\t\t\t}\n\t\t\t// TODO instance\n\t\t\tlet request = this.indexedDB.open(this.dbName, newVersion);\n\t\t\trequest.onsuccess = (event) => {\n\t\t\t\tthis.db = event.target.result;\n\t\t\t\tthis.isDBClosed = false;\n\t\t\t\tresolve(this.db);\n\t\t\t};\n\t\t\trequest.onupgradeneeded = (event) => {\n\t\t\t\tthis.db = event.target.result;\n\t\t\t\tthis.isDBClosed = false;\n\t\t\t\tresolve(this.db);\n\t\t\t};\n\t\t\trequest.onabort = (e) => {\n\t\t\t\tresolve(e);\n\t\t\t};\n\t\t\trequest.onerror = (e) => {\n\t\t\t\treject(e);\n\t\t\t};\n\t\t});\n\t}\n\tcloseDB() {\n\t\tif (this.isUpdateOpen) {\n\t\t\tthis.db.close();\n\t\t\tthis.isDBClosed = true;\n\t\t} else {\n\t\t\tif (this.timer) {\n\t\t\t\tclearTimeout(this.timer);\n\t\t\t}\n\t\t\tthis.timer = setTimeout(() => {\n\t\t\t\tthis.db.close();\n\t\t\t\tthis.isDBClosed = true;\n\t\t\t}, 1000);\n\t\t}\n\t}\n\tcacheClear() {\n\t\tconst keys = [];\n\t\tfor (let tableName in this.tableCache) {\n\t\t\tkeys.push(tableName);\n\t\t}\n\t\tfor (let tableName of keys) {\n\t\t\tconst tableCache = this.tableCache[tableName];\n\t\t\tfor (let index in tableCache) {\n\t\t\t\tdelete tableCache[index];\n\t\t\t}\n\t\t}\n\t}\n\tsetCache(tableName, key, value) {\n\t\tif (!value || !value.data) {\n\t\t\treturn;\n\t\t}\n\t\tconst data = value.data;\n\t\tfor (let key in data) {\n\t\t\tconst elm = data[key];\n\t\t\tif (elm && elm.byteLength) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!this.tableCache[tableName]) {\n\t\t\tthis.tableCache[tableName] = {};\n\t\t}\n\t\tthis.tableCache[tableName][key] = value;\n\t}\n\tgetCache(tableName, key) {\n\t\tconst tableCache = this.tableCache[tableName];\n\t\treturn tableCache ? tableCache[key] : null;\n\t}\n\tgetObjectStore(db, tableName, tables, mode) {\n\t\tif (mode === MODE_R) {\n\t\t\tthis.cacheClear();\n\t\t}\n\t\tlet transaction = db.transaction(tables, mode);\n\t\ttransaction.oncomplete = (event) => {\n\t\t\tthis.closeDB();\n\t\t};\n\t\ttransaction.onerror = (event) => {\n\t\t\tthis.closeDB();\n\t\t};\n\t\tconst table = transaction.objectStore(tableName);\n\t\treturn table;\n\t}\n\tthrowNewError(callerName) {\n\t\treturn (e) => {\n\t\t\tconsole.error(e);\n\t\t\tif (e.stack) {\n\t\t\t\tconsole.log(e.stack);\n\t\t\t} else {\n\t\t\t\tconsole.log(e.message, e);\n\t\t\t}\n\t\t\tconsole.error(\n\t\t\t\tcallerName ?\n\t\t\t\tcallerName :\n\t\t\t\t\"\" + \"/\" + e);\n\t\t\tthrow new Error(e);\n\t\t}\n\t}\n\tgetKeyPathByMap(tableName) {\n\t\treturn this.keyPathMap[tableName];\n\t}\n\tasync getKeyPath(tableName) {\n\t\tlet keyPathName = this.keyPathMap[tableName];\n\t\tif (keyPathName !== undefined && keyPathName !== null) {\n\t\t\treturn keyPathName;\n\t\t}\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"getKeyPath->getOpenDB\"));\n\t\tlet objectStore = this.getObjectStore(db, tableName, [tableName], MODE_R);\n\t\tthis.closeDB();\n\t\tlet keyPathNameCurrent = objectStore.keyPath;\n\t\tthis.keyPathMap[tableName] = keyPathNameCurrent;\n\t\treturn keyPathNameCurrent;\n\t}\n\t//private\n\tasync getCurrentVersion() {\n\t\tlet db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"getCurrentVersion->getOpenDB\"));\n\t\tconst version = db.version;\n\t\tthis.closeDB();\n\t\treturn version;\n\t};\n\t//public\n\tasync selectAll(payload) {\n\t\tlet { tableName, range, condetions } = payload;\n\t\treturn await this._selectAll(tableName, range, condetions);\n\t}\n\t//Select In-line-Keyで返す。\n\tasync _selectAll(tableName, range, direction, offset, count, callback) {\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"_selectAll->getOpenDB tableName:\" + tableName));\n\t\tlet objectStore = this.getObjectStore(db, tableName, [tableName], MODE_R);\n\t\treturn await this._selectAllExecute(objectStore, range, false, offset, count, callback);\n\t};\n\t_selectAllExecute(objectStore, range, isGetFirstOne, offset, count, callback) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst isValidCallBack = typeof offset === \"function\";\n\t\t\tconst isOnLimit = typeof offset === \"number\" && typeof count === \"number\" && offset > 0 && count > 0;\n\t\t\tconst endCount = offset + count;\n\t\t\tconst list = [];\n\t\t\tlet rowCount = 0;\n\t\t\tlet req = range === undefined ?\n\t\t\t\tobjectStore.openCursor() :\n\t\t\t\tobjectStore.openCursor(range);\n\t\t\treq.onsuccess = (event) => {\n\t\t\t\tlet cursor = event.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tconst value = cursor.value;\n\t\t\t\t\tif (isValidCallBack && !callback(value)) {\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (isOnLimit) {\n\t\t\t\t\t\tif (offset > rowCount) {\n\t\t\t\t\t\t\trowCount++;\n\t\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (endCount < rowCount) {\n\t\t\t\t\t\t\tresolve(list);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// console.log(cursor.value)\n\t\t\t\t\tlist.push(value);\n\t\t\t\t\tif (isGetFirstOne) {\n\t\t\t\t\t\tresolve(list[0]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\trowCount++;\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(list);\n\t\t\t\t}\n\t\t\t};\n\t\t\treq.onerror = (e) => {\n\t\t\t\treject(e);\n\t\t\t};\n\t\t});\n\t}\n\t//public\n\tasync selectByKey(payload) {\n\t\tlet { tableName, key } = payload;\n\t\treturn await this._selectByKey(tableName, key);\n\t}\n\t//Select In-line-return promise;Keyで返す。\n\tasync _selectByKey(tableName, key) {\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"_selectByKey->getOpenDB tableName:\" + tableName));\n\t\t// console.log(\"_selectByKey tableName:\" + tableName + \"/pk:\" + key);\n\t\t// console.log(key);\n\t\treturn await this._selectByKeyOnTran(db, tableName, key)\n\t\t\t.catch(this.throwNewError(\"_selectByKey->_selectByKeyOnTran tableName:\" + tableName + \"/mode:\" + MODE_R));\n\t}\n\t_selectByKeyOnTran(db, tableName, key, tables, mode = MODE_R) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst cachekey = tableName + \"_\" + mode;\n\t\t\tconst cache = this.getCache(cachekey, key);\n\t\t\tif (cache) {\n\t\t\t\tresolve(cache);\n\t\t\t} else {\n\t\t\t\tlet objectStore = this.getObjectStore(db, tableName, [tableName], mode);\n\t\t\t\tlet request = objectStore.get(key); //keyはsonomama\n\t\t\t\trequest.onsuccess = (event) => {\n\t\t\t\t\tconst result = request.result;\n\t\t\t\t\tresolve(result);\n\t\t\t\t\tthis.setCache(cachekey, key, result);\n\t\t\t\t};\n\t\t\t\trequest.onerror = (e) => {\n\t\t\t\t\treject(e);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n\t//public\n\tasync selectByKeys(payload) {\n\t\tlet { tableName, keys } = payload;\n\t\treturn await this._selectByKeys(tableName, keys);\n\t}\n\t//Select In-line-return promise;Keyで返す。\n\tasync _selectByKeys(tableName, keys) {\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"_selectByKeys->getOpenDB tableName:\" + tableName));\n\t\treturn await this._selectByKeysOnTran(db, tableName, keys)\n\t\t\t.catch(this.throwNewError(\"_selectByKeys->_selectByKeyOnTran tableName:\" + tableName));\n\t}\n\tasync _selectByKeysOnTran(db, tableName, keys, tables) {\n\t\tlet objectStore = this.getObjectStore(db, tableName, [tableName], MODE_R);\n\t\treturn await this._selectByKeysOnTranExec(objectStore, keys, tableName);\n\t}\n\tasync _selectByKeysOnTranExec(objectStore, keys, tableName) {\n\t\tconst retMap = {};\n\t\tfor (let key of keys) {\n\t\t\tconst cache = this.getCache(tableName, key);\n\t\t\tconst result = cache ? cache : await this._getByKeyFromeObjectStore(objectStore, key);\n\t\t\tif (!cache) {\n\t\t\t\tthis.setCache(tableName, key, result);\n\t\t\t}\n\t\t\tretMap[key] = result;\n\t\t}\n\t\treturn retMap;\n\t}\n\t_getByKeyFromeObjectStore(objectStore, key) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (!key) {\n\t\t\t\tresolve(null);\n\t\t\t}\n\t\t\tlet request = objectStore.get(key); //keyはsonomama\n\t\t\trequest.onsuccess = (event) => {\n\t\t\t\tresolve(request.result);\n\t\t\t};\n\t\t\trequest.onerror = (e) => {\n\t\t\t\treject(e);\n\t\t\t};\n\t\t});\n\t}\n\t//public\n\tasync selectFirstOne(payload) {\n\t\tlet { tableName, range, direction } = payload;\n\t\treturn await this._selectFirstOne(tableName, range, direction);\n\t}\n\t//Select FirstOnek\n\tasync _selectFirstOne(tableName, range, direction) {\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"_selectFirstOne->getOpenDB tableName:\" + tableName));\n\t\tlet objectStore = this.getObjectStore(db, tableName, [tableName], MODE_R);\n\t\treturn await this._selectAllExecute(objectStore, range, true);\n\t};\n\n\t//InsertUpdate\n\tasync insertUpdate(payload) {\n\t\tlet { tableName, data, callback } = payload;\n\t\tconst keyPathName = this.getKeyPathByMap();\n\t\treturn await this._insertUpdate(tableName, keyPathName, data, callback)\n\t\t\t.catch(this.throwNewError(\"insertUpdate->_insertUpdate tableName:\" + tableName));\n\t}\n\t//private\n\tasync bulkInsertUpdate(tableName, keyPathName, data, callback) {\n\t\tfor (let recoord of data) {\n\t\t\tawait this._insertUpdate(tableName, keyPathName, record, callback);\n\t\t}\n\t}\n\t//----------------------------------------------------------------\n\t//private\n\tasync _bulkInsertUpdate(tableName, keyPathName, data, callback) {\n\t\tconst dataList = [];\n\t\tconst keys = [];\n\t\tfor (let recoord of data) {\n\t\t\tconst key = recoord[keyPathName];\n\t\t\tdataList.push({ key, data: record });\n\t\t\tkeys.push(key);\n\t\t}\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"_insertUpdate->getOpenDB tableName:\" + tableName));\n\t\tconst tables = IdbUtil.currentTables(tableName);\n\t\tconst objectStore = this.getObjectStore(db, tableName, tables, MODE_RW);\n\t\tconst dataMap = await this._selectByKeysOnTranExec(objectStore, keys, tableName);\n\t\tawait this._bulkUpdateExecute(objectStore, tableName, dataList, dataMap);\n\t\tawait this._bulkInsertExecute(objectStore, tableName, dataList, dataMap);\n\t\tif (typeof callback === \"function\") {\n\t\t\tcallback();\n\t\t}\n\t}\n\t_bulkInsertExecute(objectStore, tableName, dataList, dataMap) {\n\t\tconst promises = [];\n\t\tfor (const { key, data } of dataList) {\n\t\t\tif (dataMap[key]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst promise = this._bulkInsertExecuteOne(objectStore, key, data);\n\t\t\tpromises.push(promise);\n\t\t}\n\t\treturn Promise.all(promises);\n\t}\n\t_bulkInsertExecuteOne(objectStore, key, data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet objectStoreRequest = objectStore.add(data); //,keyPath\n\t\t\tobjectStoreRequest.onsuccess = (event) => {\n\t\t\t\tresolve({ data, key });\n\t\t\t};\n\t\t\tobjectStoreRequest.onerror = (e) => {\n\t\t\t\tconsole.error(e);\n\t\t\t\treject(e);\n\t\t\t};\n\t\t});\n\t}\n\t_bulkUpdateExecute(objectStore, tableName, dataList, dataMap) {\n\t\tconst promises = [];\n\t\tfor (const { key, data } of dataList) {\n\t\t\tif (!dataMap[key]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst promise = this._bulkUpdateExecuteOne(objectStore, key, data);\n\t\t\tpromises.push(promise);\n\t\t}\n\t\treturn Promise.all(promises);\n\t};\n\t_bulkUpdateExecuteOne(objectStore, key, data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet objectStoreRequest = objectStore.put(data); //,keyPath\n\t\t\tobjectStoreRequest.onsuccess = (event) => {\n\t\t\t\tresolve({ data, key });\n\t\t\t};\n\t\t\tobjectStoreRequest.onerror = (e) => {\n\t\t\t\tconsole.error(e);\n\t\t\t\treject(e);\n\t\t\t};\n\t\t});\n\t}\n\t//----------------------------------------------------------------\n\t//private\n\tasync _insertUpdate(tableName, keyPathName, data, callback) {\n\t\tconst key = data[keyPathName];\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"_insertUpdate->getOpenDB tableName:\" + tableName));\n\t\tconst tables = IdbUtil.currentTables(tableName);\n\t\tconst value = await this._selectByKeyOnTran(db, tableName, key, tables, MODE_RW)\n\t\t\t.catch(this.throwNewError(\"_insertUpdate->_selectByKeyOnTran tableName:\" + tableName + \"/MODE_RW\"));\n\t\tif (callback) {\n\t\t\tcallback(value, data);\n\t\t}\n\t\tif (value === undefined) {\n\t\t\treturn await this._insertExecute(db, tableName, key, data, tables)\n\t\t\t\t.catch(this.throwNewError(\"_insertUpdate->_insertExecute tableName:\" + tableName));\n\t\t} else {\n\t\t\treturn await this._updateExecute(db, tableName, key, data, tables)\n\t\t\t\t.catch(this.throwNewError(\"_insertUpdate->_updateExecute tableName:\" + tableName));\n\t\t}\n\t}\n\t_insertExecute(db, tableName, key, data, tables) {\n\t\tlet objectStore = this.getObjectStore(db, tableName, tables, MODE_RW);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet objectStoreRequest = objectStore.add(data); //,keyPath\n\t\t\tobjectStoreRequest.onsuccess = (event) => {\n\t\t\t\tresolve({ data, key });\n\t\t\t};\n\t\t\tobjectStoreRequest.onerror = (e) => {\n\t\t\t\tconsole.error(e);\n\t\t\t\treject(e);\n\t\t\t};\n\t\t});\n\t}\n\t_updateExecute(db, tableName, key, data, tables) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet objectStore = this.getObjectStore(db, tableName, tables, MODE_RW);\n\t\t\tlet request = objectStore.put(data); //,keyPathValue\n\t\t\trequest.onsuccess = (event) => {\n\t\t\t\tresolve({ data, key });\n\t\t\t};\n\t\t\trequest.onerror = (e) => {\n\t\t\t\tconsole.error(e);\n\t\t\t\tresolve(e);\n\t\t\t};\n\t\t});\n\t};\n\t//public\n\tasync deleteWithRange(payload) {\n\t\tlet { tableName, range, condetions } = payload;\n\t\treturn await this._deleteWithRange(tableName, range, condetions);\n\t}\n\t//Delete\n\tasync _deleteWithRange(tableName, range, condetions) {\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"_deleteWithRange->getOpenDB tableName:\" + tableName));\n\t\tconst tables = IdbUtil.currentTables(tableName);\n\t\treturn await this._deleteWithRangeExecute(db, tableName, range, condetions, tables);\n\t};\n\t_deleteWithRangeExecute(db, tableName, range, condetions, tables) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet objectStore = this.getObjectStore(db, tableName, tables, MODE_RW);\n\t\t\tlet request = objectStore.openCursor(range);\n\t\t\trequest.onsuccess = (event) => {\n\t\t\t\tlet cursor = event.target.result;\n\t\t\t\tlet list = [];\n\t\t\t\tif (cursor) {\n\t\t\t\t\tlet value = cursor.value;\n\t\t\t\t\tif (IdbUtil.isMutch(value, condetions)) {\n\t\t\t\t\t\tlet or = objectStore.delete(cursor.key);\n\t\t\t\t\t\tor.onsuccess = (event) => {\n\t\t\t\t\t\t\tlist.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tor.onerror = (e) => {\n\t\t\t\t\t\t\t//momiee\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tresolve(list);\n\t\t\t\t}\n\t\t\t};\n\t\t\trequest.onerror = (e) => {\n\t\t\t\treject(e);\n\t\t\t};\n\t\t});\n\t}\n\t//public\n\tasync delete(payload) {\n\t\tlet { tableName, key } = payload;\n\t\treturn await this._delete(tableName, key);\n\t}\n\t//Delete\n\tasync _delete(tableName, keyPathValue) {\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"_delete->getOpenDB tableName:\" + tableName));\n\t\tconst tables = IdbUtil.currentTables(tableName);\n\t\treturn await this._deleteOnTran(db, tableName, keyPathValue, tables);\n\t};\n\t_deleteOnTran(db, tableName, key, tables) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet objectStore = this.getObjectStore(db, tableName, tables, MODE_RW);\n\t\t\tlet request = objectStore.delete(key + \"\");\n\t\t\trequest.onsuccess = (event) => {\n\t\t\t\tresolve({ tableName, key });\n\t\t\t}\n\t\t\trequest.onerror = (e) => {\n\t\t\t\tconsole.error(e);\n\t\t\t\treject(e);\n\t\t\t};\n\t\t});\n\t}\n\t//public\n\tasync truncate(payload) {\n\t\tlet { tableName } = payload;\n\t\treturn await this._truncate(tableName);\n\t}\n\t//truncate\n\tasync _truncate(tableName) {\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"_truncate->getOpenDB tableName:\" + tableName));\n\t\tconst tables = IdbUtil.currentTables(tableName);\n\t\treturn await this._truncateExecute(db, tableName, tables);\n\t};\n\t//truncate\n\t_truncateExecute(db, tableName, tables) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet objectStore = this.getObjectStore(db, tableName, tables, MODE_RW);\n\t\t\tlet request = objectStore.clear();\n\t\t\trequest.onsuccess = (event) => {\n\t\t\t\tresolve();\n\t\t\t};\n\t\t\trequest.onerror = (e) => {\n\t\t\t\treject(e);\n\t\t\t};\n\t\t});\n\t};\n\tasync getObjectStoreNames() {\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"getObjectStoreNames->getOpenDB\"));\n\t\tconst names = db.objectStoreNames;\n\t\tthis.closeDB();\n\t\treturn names;\n\t}\n\tasync isExistsObjectStore(tableName) {\n\t\tconst db = await this.getOpenDB()\n\t\t\t.catch(this.throwNewError(\"isExistsObjectStore->getOpenDB tableName:\" + tableName));\n\t\tlet isExist = false;\n\t\tfor (let name of db.objectStoreNames) {\n\t\t\tif (name === tableName) {\n\t\t\t\tisExist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.closeDB();\n\t\treturn isExist;\n\t}\n\t//public\n\tasync createStore(payload) {\n\t\tlet { tableName, keyPathName, isAutoIncrement } = payload;\n\t\treturn await this._createStore(tableName, keyPathName, isAutoIncrement);\n\t}\n\t//createStore\n\tasync _createStore(tableName, keyPathName, isAutoIncrement) {\n\t\tconst isExistsObjectStore = await this.isExistsObjectStore();\n\t\tif (isExistsObjectStore === false) {\n\t\t\tconst newVersion = (await this.getCurrentVersion()) + 1;\n\t\t\tconst db = await this.getOpenDB(newVersion)\n\t\t\t\t.catch(this.throwNewError(\"_createStore->getOpenDB tableName:\" + tableName));\n\t\t\tlet isExist = false;\n\t\t\tfor (let name of db.objectStoreNames) {\n\t\t\t\tif (name === tableName) {\n\t\t\t\t\tisExist = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isExist === false) {\n\t\t\t\tdb.createObjectStore(tableName, { keyPath: keyPathName });\n\t\t\t}\n\t\t\tthis.closeDB();\n\t\t};\n\t};\n\t//public\n\tasync dropStore(payload) {\n\t\tlet { tableName } = payload;\n\t\treturn await this._dropStore(tableName);\n\t}\n\t//DropStore\n\tasync _dropStore(tableName) {\n\t\tconst newVersion = (await this.getCurrentVersion()) + 1;\n\t\tconst db = await this.getOpenDB(newVersion)\n\t\t\t.catch(this.throwNewError(\"_dropStore->getOpenDB tableName:\" + tableName));\n\t\tdb.deleteObjectStore(tableName);\n\t\tthis.closeDB();\n\t\treturn;\n\t};\n}","import { IdbUtil } from './idbUtil'\nimport { IndexeddbCore } from './indexeddbCore'\nconst MODE_R = \"readonly\";\nconst MODE_RW = \"readwrite\";\nconst cmdSelectAll = \"cmdSelectAll\";\nconst cmdSelectByKey = \"cmdSelectByKey\";\nconst cmdSelectByKeys = \"cmdSelectByKeys\";\nconst cmdSelectFirstOne = \"cmdSelectFirstOne\";\nconst cmdInsertUpdate = \"cmdInsertUpdate\";\nconst cmdDeleteWithRange = \"cmdDeleteWithRange\";\nconst cmdDelete = \"cmdDelete\";\nconst cmdTruncate = \"cmdTruncate\";\nconst cmdCreateStore = \"cmdCreateStore\";\nconst cmdGetObjectStoreNames = \"cmdGetObjectStoreNames\";\nexport class IndexeddbHelper {\n\tconstructor(dbName) {\n\t\tthis.core = new IndexeddbCore(dbName);\n\t\tthis.queue = [];\n\t\tthis.lastTaskMode = null;\n\t\tthis.lastLockTime = new Date()\n\t\t\t.getTime();\n\t\tthis.counter = 0;\n\t}\n\n\tasync deQueue() {\n\t\t// console.log(\"deQueue1---:this.counter:\" + this.counter);\n\t\tif (this.counter < 1) {\n\t\t\tthis.counter++;\n\t\t\tif (this.counter > 1) {\n\t\t\t\tthis.counter--;\n\t\t\t\tsetTimeout(async () => { await this.deQueue() }, 0);\n\t\t\t} else {\n\t\t\t\tawait this.deQueueExec();\n\t\t\t\t// console.log(\"deQueue2:this.queue.length:\" + this.queue.length);\n\t\t\t\tthis.counter--;\n\n\t\t\t\t// console.log(\"deQueue3:this.counter:\" + this.counter);\n\t\t\t\tif (this.counter < 1 && this.queue.length > 0) {\n\t\t\t\t\t// console.log(\"deQueue4:this.counter:\" + this.counter);\n\t\t\t\t\tthis.deQueue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdeQueueExec() {\n\t\treturn new Promise(\n\t\t\t(resolve, reject) => {\n\t\t\t\twhile (this.queue.length > 0) {\n\t\t\t\t\t// console.log(\"deQueueExec:1\" + \"this.counter:\" + this.counter);\n\t\t\t\t\tconst promises = [];\n\t\t\t\t\tconst selectTasks = [];\n\t\t\t\t\twhile (this.queue.length > 0) {\n\t\t\t\t\t\t// console.log(\"deQueueExec:2\" + \"this.counter:\" + this.counter);\n\t\t\t\t\t\tconst task = this.queue.shift();\n\t\t\t\t\t\tif (task) {\n\t\t\t\t\t\t\tif (this.lastTaskMode !== task.mode || task.mode === MODE_RW) {\n\t\t\t\t\t\t\t\t//ここでそのまま発行、そして終わるまで待機\n\t\t\t\t\t\t\t\tif (promises.length > 0) {\n\t\t\t\t\t\t\t\t\tPromise.all(promises)\n\t\t\t\t\t\t\t\t\t\t.then(\n\t\t\t\t\t\t\t\t\t\t\t(results) => {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (let index in results) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst taskOfRead = selectTasks[index];\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst result = results[index];\n\t\t\t\t\t\t\t\t\t\t\t\t\ttaskOfRead.resolve(result);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tpromises.splice(0, promises.length);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.executUpdateTask(task, resolve);\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t(error) => {\n\t\t\t\t\t\t\t\t\t\t\t\talert(error);\n\t\t\t\t\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.executUpdateTask(task, resolve);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t//じゃんじゃん流していこう。\n\t\t\t\t\t\t\t\tconst promise = this.execCmd(task.cmd, task.data);\n\t\t\t\t\t\t\t\tpromises.push(promise);\n\t\t\t\t\t\t\t\tselectTasks.push(task);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.lastTaskMode = task.mode;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//なんだっけ\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (promises.length > 0) {\n\t\t\t\t\t\tPromise.all(promises)\n\t\t\t\t\t\t\t.then(\n\t\t\t\t\t\t\t\t(results) => {\n\t\t\t\t\t\t\t\t\tfor (let index in results) {\n\t\t\t\t\t\t\t\t\t\tconst taskOfRead = selectTasks[index];\n\t\t\t\t\t\t\t\t\t\tconst result = results[index];\n\t\t\t\t\t\t\t\t\t\ttaskOfRead.resolve(result);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tpromises.splice(0, promises.length);\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t(error) => {\n\t\t\t\t\t\t\t\t\talert(error);\n\t\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\texecutSelectPromiseAndTask(task, resolve, updateTask) {\n\t\tif (updateTask) {\n\t\t\tthis.executUpdateTask(updateTask, resolve);\n\t\t}\n\t}\n\texecutUpdateTask(task, resolve) {\n\t\tconst promise = this.execCmd(task.cmd, task.data);\n\t\tpromise.then((data) => {\n\t\t\ttask.resolve(data);\n\t\t\tresolve(data);\n\t\t});\n\t}\n\tenQueueReadTask(cmd, data) {\n\t\treturn this.enQueueTask(cmd, data, MODE_R);\n\t}\n\tenQueueWriteTask(cmd, data) {\n\t\treturn this.enQueueTask(cmd, data, MODE_RW);\n\t}\n\tenQueueTask(cmd, data, mode) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst task = { cmd, data, resolve, reject, mode };\n\t\t\t// console.log(\"this.enQueueTask1:\" + this.counter);\n\t\t\tthis.queue.push(task);\n\t\t\t// console.log(\"this.enQueueTask2:\" + this.counter);\n\t\t\tthis.deQueue();\n\t\t\t// console.log(\"this.enQueueTask3:\" + this.counter);\n\t\t});\n\t}\n\n\tasync execCmd(cmd, data) {\n\t\t// console.log(\"cmd:\" + cmd + \"/data:\" + data);\n\t\tif (cmdSelectAll === cmd) {\n\t\t\treturn await this.core._selectAll(data.tableName, data.range, data.direction, data.offset, data.limmitCount);\n\t\t}\n\t\tif (cmdSelectByKey === cmd) {\n\t\t\treturn await this.core._selectByKey(data.tableName, data.key);\n\t\t}\n\t\tif (cmdSelectByKeys === cmd) {\n\t\t\treturn await this.core._selectByKeys(data.tableName, data.keys);\n\t\t}\n\t\tif (cmdSelectFirstOne === cmd) {\n\t\t\treturn await this.core._selectFirstOne(data.tableName, data.range, data.direction);\n\t\t}\n\t\tif (cmdInsertUpdate === cmd) {\n\t\t\treturn await this.core._insertUpdate(data.tableName, data.keyPathName, data.data, data.callback);\n\t\t}\n\t\tif (cmdDeleteWithRange === cmd) {\n\t\t\treturn await this.core._deleteWithRange(data.tableName, data.range, data.condetions);\n\t\t}\n\t\tif (cmdDelete === cmd) {\n\t\t\treturn await this.core._delete(data.tableName, data.keyPathValue);\n\t\t}\n\t\tif (cmdTruncate === cmd) {\n\t\t\treturn await this.core._truncate(data.tableName);\n\t\t}\n\t\tif (cmdCreateStore === cmd) {\n\t\t\treturn await this.core._createStore(data.tableName, data.keyPathName, data.isAutoIncrement);\n\t\t}\n\t\tif (cmdGetObjectStoreNames === cmd) {\n\t\t\treturn await this.core.getObjectStoreNames();\n\t\t}\n\t}\n\n\t//Select In-line-Keyで返す。\n\tasync selectAllForwardMatch(tableName, key, direction, offset, limmitCount) {\n\t\tconst nextKey = key.slice(0, -1) + String.fromCharCode(key.slice(-1)\n\t\t\t.charCodeAt() + 1);\n\t\tconst range = IDBKeyRange.bound(str, nextStr, false, true);\n\t\treturn await this.enQueueReadTask(cmdSelectAll, { tableName, range, direction, offset, limmitCount });\n\t};\n\t//Select In-line-Keyで返す。\n\tasync selectAll(tableName, range, direction, offset, limmitCount) {\n\t\treturn await this.enQueueReadTask(cmdSelectAll, { tableName, range, direction, offset, limmitCount });\n\t};\n\t//Select In-line-return promise;Keyで返す。\n\tasync selectByKey(tableName, key) {\n\t\treturn await this.enQueueReadTask(cmdSelectByKey, { tableName, key });\n\t}\n\t//Select In-line-return promise;Keyで返す。\n\tasync selectByKeys(tableName, keys) {\n\t\treturn await this.enQueueReadTask(cmdSelectByKeys, { tableName, keys });\n\t}\n\t//Select FirstOnek\n\tasync selectFirstOne(tableName, range, direction) {\n\t\treturn await this.enQueueReadTask(cmdSelectFirstOne, { tableName, range, direction });\n\t};\n\n\t//private\n\tasync insertUpdate(tableName, keyPathName, data, callback) {\n\t\treturn await this.enQueueWriteTask(cmdInsertUpdate, { tableName, keyPathName, data, callback });\n\t}\n\t//Delete\n\tasync deleteWithRange(tableName, range, condetions) {\n\t\treturn await this.enQueueWriteTask(cmdDeleteWithRange, { tableName, range, direction });\n\t};\n\t//Delete\n\tasync delete(tableName, keyPathValue) {\n\t\treturn await this.enQueueWriteTask(cmdDelete, { tableName, keyPathValue });\n\t};\n\t//truncate\n\tasync truncate(tableName) {\n\t\treturn await this.enQueueWriteTask(cmdTruncate, { tableName });\n\t};\n\t//truncate\n\tasync createStore(tableName, keyPathName, isAutoIncrement) {\n\t\treturn await this.enQueueWriteTask(cmdCreateStore, { tableName, keyPathName, isAutoIncrement });\n\t};\n\tasync getObjectStoreNames() {\n\t\treturn await this.enQueueReadTask(cmdGetObjectStoreNames, {});\n\t}\n}","import { IndexeddbAccessor } from './indexeddbAccessor'\nimport constant from './constant'\nconst idbAccessors = new Map();\nlet currentDbName = constant.dbName;\nexport class idbw {\n\tconstructor(dbName) {\n\t\tthis.dbName = dbName;\n\t\t// not use\n\t}\n\tasync getObAccessor(obName, keypathName) {\n\t\tif (idbAccessors.has(obName)) {\n\t\t\treturn idbAccessors.get(obName);\n\t\t}\n\t\tconst accessor = new IndexeddbAccessor(obName, keypathName, this.dbName);\n\t\tidbAccessors.set(obName, accessor);\n\t\tawait accessor.init();\n\t\treturn accessor;\n\t}\n};"],"sourceRoot":""}